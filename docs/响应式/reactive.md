# 为什么容器采用WeakMap而不采用Map
因为WeakMap是弱引用，key作为一个对象如果没有被引用，那么到时候会被垃圾回收机制所回收，反之Map不是弱引用，将会导致如果没有被引用，对象仍然可以被访问，不会被垃圾回收机制所回收。(也就是说每次执行完依赖函数，target数据自动在weakMap被清空)
# reactive响应式原理
当访问该数据会被proxy劫持到，然后会将effect依赖存储下来，首先会有一个全局变量weakMap来统一存储全部依赖，接下来key便是target对象 value便是一个map对象 map对象内部key就是用户访问的属性 value则是一个Set集合，Set集合就是存储的effect副作用函数依赖，当数据发生改变的时候就会执行对应effect依赖
对于分支切换采用每次执行effect函数前先清空当前依赖，并且在拿到Set后再重新创建Set解决递归问题
对于effect嵌套问题，采用栈数组方式解决，每次执行栈前把effect放到栈中，执行完成后进行出栈然后将stack的第一个元素赋值给activeEffect，这样不会影响到外部effect重新执行
